https://try.github.io/levels/1/challenges/12

Directory:
A folder used for storing multiple files.
Repository:
A directory where Git has been initialized to start version controlling your files.

Our terminal prompt below is currently in a directory we decided to name "octobox". 
To initialize a Git repository here, type the following command:
 $git init
 
 Initialized empty Git repository in /.git/

Success!

As Git just told us, our "octobox" directory now has an empty repository in /.git/. 
he repository is a hidden directory where Git operates.
 
Next up, let's type the git status command to see what the current state of our project is:
$ git status
 

# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)

Success!

I created a file called octocat.txt in the octobox repository for you.
You should run the git status command again to see how the repository status has changed:
$ git status
 

# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	octocat.txt
nothing added to commit but untracked files present (use "git add" to track)

Success!

staged:
Files are ready to be committed.
unstaged:
Files with changes that have not been prepared to be committed.
untracked:
Files aren't tracked by Git yet. This usually indicates a newly created file.
deleted:
File has been deleted and is waiting to be removed from Git.

Notice how Git says octocat.txt is "untracked"? That means Git sees that octocat.txt is a new file.
To tell Git to start tracking changes made to octocat.txt, we first need to add it to the staging area by using git add.
$ git add octocat.txt

add all:
You can also type git add -A . where the dot stands for the current directory, so everything in and beneath it is added. 
The -A ensures even file deletions are included.
git reset:
You can use git reset <filename> to remove a file or files from the staging area.

Git is now tracking our octocat.txt file. Let's run git status again to see where we stand:
$ git status
 

# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#
#	new file:   octocat.txt
#

Success!

Staging Area:
A place where we can group files together before we "commit" them to Git.
Commit
A "commit" is a snapshot of our repository. This way if we ever need to look back at the changes we've made 
(or if someone else does), we will see a nice timeline of all changes.

Notice how Git says changes to be committed? The files listed here are in the Staging Area, and they are not in our repository yet.
We could add or remove files from the stage before we store them in the repository.
To store our staged changes we run the commit command with a message describing what we've changed. Let's do that now by typing:

$ git commit -m "Add cute octocat story"
 

[master (root-commit) 20b5ccd] Add cute octocat story
 1 file changed, 1 insertion(+)
 create mode 100644 octocat.txt

Success!

You also can use wildcards if you want to add many files of the same type.
Notice that I've added a bunch of .txt files into your directory below.

Wildcards:
We need quotes so that Git will receive the wildcard before our shell can interfere with it. 
Without quotes our shell will only execute the wildcard search within the current directory. 
Git will receive the list of files the shell found instead of the wildcard and it will not be able 
to add the files inside of the octofamily directory.


I put some in a directory named "octofamily" and some others ended up in the root of our "octobox" directory.
Luckily, we can add all the new files using a wildcard with git add. Don't forget the quotes!

$ git add '*.txt'
 

Success!

Check all the things!
When using wildcards you want to be extra careful when doing commits. 
Make sure to check what files and folders are staged by using git status before you do the actual commit. 
This way you can be sure you're committing only the things you want.
$ git status
 

# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	new file:   blue_octocat.txt
#	new file:   octofamily/baby_octocat.txt
#	new file:   octofamily/momma_octocat.txt
#	new file:   red_octocat.txt
#

Did not use git commit

$ git commit -m 'Add all the octocat txt files'
 

[master 3852b4d] Add all the octocat txt files
 4 files changed, 4 insertions(+)
 create mode 100644 blue_octocat.txt
 create mode 100644 octofamily/baby_octocat.txt
 create mode 100644 octofamily/momma_octocat.txt
 create mode 100644 red_octocat.txt

Success!

 History
So we've made a few commits.
Now let's browse them to see what we changed.
Fortunately for us, there's git log. 
Think of Git's log as a journal that remembers all the changes we've committed so far, in the order we committed them. 

More useful logs:
Use git log --summary to see more information for each commit. 
You can see where new files were added for the first time or where files were deleted. 
It's a good overview of what's going on in the project.

$ git log
 

commit 3852b4db1634463d0bb4d267edb7b3f9cd02ace1
Author: Try Git <try_git@github.com>
Date:   Sat Oct 10 08:30:00 2020 -0500

    Add all the octocat txt files

commit b652edfd888cd3d5e7fcb857d0dabc5a0fcb5e28
Author: Try Git <try_git@github.com>
Date:   Sat Oct 10 08:30:00 2020 -0500

    Added cute octocat story

Success!

git remote:
Git doesn't care what you name your remotes, but it's typical to name your main one origin.
It's also a good idea for your main repository to be on a remote server like GitHub.

We've gone ahead and created a new empty GitHub repository for you to use with Try Git at https://github.com/try-git/try_git.git. 
To push our local repo to the GitHub server we'll need to add a remote repository.
This command takes a remote name and a repository URL, which in your case is https://github.com/try-git/try_git.git.
Go ahead and run git remote add with the options below:
$ git remote add origin https://github.com/try-git/try_git.git

Success!

Cool Stuff:
When you start to get the hang of git you can do some really cool things with hooks when you push.
For example, you can upload directly to a webserver whenever you push to your master remote instead of 
having to upload your site with an ftp client. Check out Customizing Git - Git Hooks for more information.

Pushing Remotely
The push command tells Git where to put our commits when we're ready, and boy we're ready. 
So let's push our local changes to our origin repo (on GitHub).
$ git push -u origin master
 
Branch master set up to track remote branch master from origin.

Success!

The name of our remote is origin and the default local branch name is master. The -u tells Git to remember the parameters, so that next time we can simply run git push and Git will know what to do. Go ahead and push it!
